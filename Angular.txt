Criar um projeto angular: ng new nome_projeto --prefix=escolha_um_prefixo
O --prefix é opcional. Ele determina que, ao criar um novo componente, o nome dele sempre tera o prefixo escolhido

Rodar programa: ng serve

Criar componentes: ng g c nome_do_componente (adicionar --spec=false se não quiser arquivos de teste gerados)

localhost:4200 é onde as aplicações angular rodam no navegador

---------------------------------------------------------------------------------------------------------
Instruções básicas:
Os componentes são declarados nos modulos

@Input() passa valores para os componentes no arquivo .ts

@Output() nome_evento = new EventEmitter emite eventos

ngOnInit() serve para executar algo assim que o componente é iniciado

ngAfterContentInit() serve para executar algo logo após todo o conteúdo do componente for iniciado

Colocar uma ? no método, condição, parâmetro ou variável torna ele opcional

*ngIf="true/false" é o equivalente ao if comum

*ngFor="let nome_elemento of nome_coleção" é o equivalente ao for comum

*ngSwitch="nome_variavel" *ngSwitchCase="nome_conteudo" *ngSwitchDefault="saida_padrao" é o equivalente ao SwitchCase comum

Colocar ${texto} dentro de um texto entre aspas, faz reconhecer o que está entre chaves como uma variável

(click) serve para fazer algo ao clicar

(mouseenter) e (mouseleave) serve para chamar uma função quando o mouse entra ou sai do objeto

Você pode colocar uma referência nas suas tags para direcionar algum evento a elas. Ex: <div #nome_referencia> ... </div>

<router-outlet> é a tag que indica que as telas serão exibidas de forma dinâmica ao trocar de rota

<ng-content> permite passar qualquer conteúdo entre as tags de abertura e fechamento do componente criado
@ContentChild no arquivo .ts serve para se comunicar com o conteúdo do ng-content

As rotas são definidas geralmente no arquivo app.router.ts da seguinte forma:
export const ROUTES: Routes = [
    {path: '', component: NomeComponent}
]
E logo após isso importar no arquivo app.module.ts da seguinte forma: RouterModule.forRoot(ROUTES)

[routerLink]="['/nome_do_path']" para direcionar para a rota desejada
routerLinkActive="nome_para_css" para indicar que um elemento está ativo de acordo com a rota e aplicar o nome css neste caso

Você pode usar o router.navigate no arquivo .ts para mudar de rota em funções

Para ler as variáveis nos arquivos html, colocá-las entre duas chaves {{nome_variável}}

Uso de rotas parametrizadas quando parte da rota vai identificar um objeto que está no backend
Identificada quando ao final do path da rita tiver um /:id
Chamar essas rotas pode ser feita com um snapshot (algo mais estático) ou subscribe (mudando a rota em tempo real)
snapshot não vai dar o valor atualizado caso precise, já o subscribe abre um canal para ouvir mudanças de valores nos parâmetros.
O snapshot pode ser mais conveniente quando não precisar de valores atualizados
snapshot: this.route.snapshot.params['id']
subscribe this.route.subscribet.params['id']

Em app.route as rotas ficarão assim:
{path: 'nome_rota', component: NomeComponent},
    {path: 'nome_rota/:id', component: NomeRotaFiflhaComponent,
        children: [
            {path: '', redirectTo: 'menu', pathMatch: 'full'},
            {path: 'nome_subRota1', component: NomeSubRota1Component},
            {path: 'nome_subRota2', component: NomeSubRota2Component}
        ]},

O nome_rota nos dois primeiros path é igual para indicar que uma rota está dentro da outra mas mostrando um elemento diferente com o id
O nome_rota/:id seria como vc acessar uma janela que faz parte de outra, por exemplo, numa tela que lista restaurantes vc clica
	em um restaurante para abrir uma tela de descrição.
A subRota é para indicar que dentro da rota filha tambem tem mudanças de rota, como por exemplo, um submenu que troca o conteúdo
	por abas


Pipes servem para transformar o conteúdo. Ex: {{user.name | uppercase}} faz com que a saída seja toda em maiúscula
alguns nomes de pipes:
uppercase - transforma em maiúscula
lowercase - transforma em minúscula
percent - transforma em porcentagem
date - formato data (date: 'dd/MM/yyyy')
currency - formato monetário (currency: 'BRL': true)
slice - limita arrays e strings ({{user.name | slice: 0:4}} a saída será apenas os 4 primeiros caracteres)
async - faz o subscribe direto no item

Pipes podem ser combinados com outros pipes

[class.atributo_classe]="condição" para definir no html o atributo da tag para ser mexina no css
-------------------------------------------------------------------------------------------------------------

Funções:
ngOnInit() executa o código pelo menos uma vez na inicialização

---------------------------------------------------------------------------------------------------------------


Propriedades:
[hidden]=true/false esconde a div. É escondido via css, então melhor não usar

-----------------------------------------------------------------------------------------------------------

Observables:
map tranforma os itens
filter filtra os itens
subscribe é similar ao forEach em que cada item do array será passado para o argumento do método subscribe

------------------------------------------------------------------------------------------------------------
Conexão com o banco
Um arquivo api.ts pode ser criado e dentro dele exportar uma constante com o localhost do banco
ex: export const NOME_API = 'http://localhost:numero_porta'
Esse artquivo é importado pelo arquivo nome_service.ts

Para uma classe de serviço receber um outro servuiço, é necessário a marcação @Injectable()

O http é declarado no contrutor do arquivo service.ts. ex: constructor(private http: Http)

Em alguma função que retorna um observable com o array do tipo de dado que o banco te dá
EX: nome_funcao() Observable<tipo_dado[]>
Usar get para pegar as informações
Ex: return this.http.get(`${NOME_API}/nome_rota_criada_pelo_banco`)
Lembre-se: o sinal de crase (não são aspas simples) é para concatenar tudo que está dentro
	   O sinal de $ é para reconhecer o que está entre chaves como uma variável
É necessário usar map para transformar a resposta do observable (dados do tipo response) no array de dados desejados
Ex: return this.http.get(`${NOME_API}/nome_rota_criada_pelo_banco`).map(response => response.json())
Lembre-se: a extensão .json é porque usei o json-server como banco de dados. Ficar atento à extensão correta

A requisição não é feita até ser feito um subscribe no componente.ts
Ex:
ngOnInit(){
	this.nome_servico.nome_funcao()
	 .subscribe(nome_variavel => this.nome_variavel = nome_variavel_de_retorno_da_funcao)
}
Lembre-se: o nome_servico é o servico que está fazendo a chamada http
	   o nome_funcao é a funcao que está dando return no http.get
	   o nome_variavel_de_retorno_da_funcao é cada elemento do array que retorna da funcao
	   o => é uma arrow function. O que vem antes da seta (=>) são os argumentos. O que vem depois é a implementação. 
	   Neste caso, temos um argumento e a implementação da função é atribuir o valor do argumento ao atributo do componente.
	   A sintaxe está mais enxuta, mas seria como se escrevêssemos:
		.subscribe (function(nome_variavel){
   		this.nome_variavel = nome_variavel_de_retorno_da_funcao
		})

-------------------------------------------------------------------------------------------------
Tratar erros

Tratar com catch e errorHandler

Como errorHandler é um erro global, criou-se o arquivo app.error-handler.ts e nele o método static handleError(error: Response | any)
Lembre-se: Response é um objeto da API do angular que representa a resposta. E any é pra mostrar que o erro aceita o tipo Response
	   ou qualquer um

Ex: 

export class ErrorHandler{
    static handleError(error: Response | any){
        let errorMessage: string

        if(error instanceof Response){
            errorMessage = `Erro ${error.status} ao acessar a URL ${error.url} - ${error.statusText}`
        }else{
            errorMessage = error.toString()
        }
        console.log(errorMessage)

        return Observable.throw(errorMessage)
        
    }
}
errorMessage é uma variavel criada para guardar a mensagem de erro. Pode ter qualquer nome
instanceof é um operador que permite testar se um objeto é uma instância de um tipo específico de uma class, subclass ou interface
	   Se for, retorna true, se não false
error.status é o número do erro e error.statusText é a descrição do erro
Throw é o que vai jogar o erro para o observable

De volta ao componente.ts colocar .catch ao final do observable para pegar o erro caso ocorra
ex: this.nome_servico.nome_funcao()
	 .subscribe(nome_variavel => this.nome_variavel = nome_variavel_de_retorno_da_funcao)
	 .catch(ErrorHandler.handleError)
Lembre-se: ErrorHandler é o nome do arquivo app.error-handler.ts que foi criado
	   handleError é o nome da função que foi criada

------------------------------------------------------------------------------------------------------------------
Formulários (new)

Reactive forms é a mais nova forma de criar formulários no angular

Se usa com um formgroup e um formbuilder no arquivo .ts
ex: userform: FormGroup
    contructor(private fb: FormBuilder){}
    ngOnInit(){
	this.userform = this.fb.group({
	    username: '',
	    password: '',
	})
    }

Os resultados dos campos também podem ser obtidos com o metodo control
ex: username: this.fb.control(''),
    password: this.fb.control('')

Validadores também podem ser passados pelo control
ex: username: this.fb.control('', [Validators.required]),
    password: this.fb.control('', [Validatiors.minlength(3)])

Você também pode agrupar os campos para fazer a validação entre os componentes agrupados
ex: this.userform = this.fb.group({
	    username: '',
	    password: '',
	    address: this.fb.group({
		street: '',
		zip: ''
	    })
	})

O template não possui mais o ngmodel. Agora usamos formGroup para indicar o grupo e formControlName para indicar
o nome dos campos. Se você tiver um grupo, pode associá-la com formGroupName
ex: <form [formGroup]="userform">
	<input type="text" formControlName="username" />
	<input type="password" formControlName="password" />

	<div formGroupName="address">
	    <input type="text" formControlName="street" />
	    <input type="text" formControlName="zip" />
	</div>

    </form>

Não se esqueça de importar o ReactiveFormsModule no app.module ou no console do browser vai acusar não ter provider
------------------------------------------------------------------------------------------------------------------
Formulários (old)

Se faz com a tag <form>. Todo form é um ngForm

Todo form deve ter o atributo name e a diretiva ngModel
ex: <input type="text" name="nome" ngModel>

Para inserir o valor no ngModel é só colocaá-lo entre colchetes como as outras diretivas. Quando o valor do
componente mudar, o campo é atualizado mas o inverso não acontece
ex: username: string= = "nome do usuário"
    <input type="text" name="nome" [ngModel]="username">

Para o inverso também acontecer devemos usar o two-way binding, colocando o ngModel entre colchetes e parenteses
ex: username: string= = "nome do usuário"
    <input type="text" name="nome" [(ngModel)]="username">

Também é possivel obter referências no form
ex: <form #myForm="ngForm">
    <input type="text" name="nome" ngModel />
    <button [disabled]="myForm.invalid" />

Para desabilitar a validação padrão, basta colocar a diretiva novalidate
ex: <form #form="ngForm" novalidate>

Os formularios têm os seguintes estados para ajudar a dar feedback visual ao usuário: valid ou invalid, pristine ou dirty
e touched ou untouched

Para saber os estados é necessario uma referência para a diretiva ngModel do campo
ex: <form>
	<input name="nome" [(ngModel)]="username" #ipt="ngModel">
	<span *ngIf="ipt.invalid"> Nome inválido </span>
    </form>

As validações que podemos atribuir a um campo são: required, pattern, minlenght e maxlenght

[disabled]="!form.valid" em um botão para desabilitá-lo caso o formulário não seja válido

Para fazer com que outros componentes contem como fazendo parte do form, tipo um botão de radio, é necessário usar o
ControlValueAccessor e colocar os providers no arquivo .ts
ex: @Component({
  selector: 'mt-radio',
  templateUrl: './radio.component.html',
  providers: [
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => RadioComponent),
      multi: true
    }
  ]
})
export class RadioComponent implements OnInit, ControlValueAccessor {

De forma simplificada é a maneira como registramos o componente no framework. Usamos esse token (NG_VALUE_ACCESSOR)
para registrar o componente que acabamos de criar. O Angular vai usar os valores desse token para passar as referências
para a API de forms. 
Usamos "forwardRef" porque no momento que esse provider for obtido, o componente ainda não está registrado, então
basicamente declaramos uma referência de que ele vai estar disponível posteriormente.

Lembre-se de implementar as funções da interface do ControlValueAccessor: writeValue, registerOnChange e registerOnTouched
No método "registerOnChange", é recebida uma referência a uma função que deve ser chamada sempre que o valor interno
do componente mudar. Isso é necessário para notificar o formulário do novo valor

Após isso, lembre-se que o componente no formulário deve ter um name e o ngModel

Outra forma de fazer essa integração de componentes no form é com o ng-content

O valor de retorno de um formulário pode ser conferido com form.value